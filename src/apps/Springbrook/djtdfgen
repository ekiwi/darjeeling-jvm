#!/usr/bin/env python

# Darjeeling equivalent  of fostdfgen:  reads tdf.txt and  outputs the
# node-side java code to transmit TDF packets

import re,sys


SID_count = 8;

##########################################
# Default file name
if len(sys.argv) == 1:
    tdf_keys_filename='tdf.txt'
else:
    tdf_keys_filename=sys.argv[1]

input_file=open(tdf_keys_filename,'r')
output_file=open('TDF.java','w')

generated_text={}

generated_text['SID_KEYS']=''
generated_text['SID_CASES']=''

##########################################
# parse keys file

# white space, then optionnal commented content, then end of line
comment_pattern        = re.compile(r'\s*([#%].*)?$')

# SID name, then integer or 'struct-like' declaration
key_definition_pattern = re.compile(r'''([a-zA-Z]\w*)\s*((?:\d+)|(?:{[^}]+}))''');

for line in input_file:
    # does the line look like a comment
    if comment_pattern.match(line):
        #print "comment: ",line,
        continue

    # does the line look like a valid line
    match=key_definition_pattern.match(line)
    if match == None:
        print "bad line format:", line,
        continue


    # Here we are sure that the line is valid

    elif match.group(2) == '2':
        generated_text['SID_KEYS'] += \
            (' '*4+'public static final byte %s = %s;\n'
             % (match.group(1),str(SID_count)) )
    else:
        generated_text['SID_KEYS'] += \
            (' '*4+'// not supported:  %s %s\n'
             % (match.group(1),match.group(2)) )

    
    
    SID_count+=1;

##########################################
# Write output

output_file.write('''/*
    This file has been autogenerated by djtdfgen, do not edit
*/

public class TDF
{
%(SID_KEYS)s
    // This buffer holds pairs of the form (SID, value).
    //
    // Each time a reading is pushed into the buffer, the 'value' part
    // of a pair gets updated.
    //
    // Pairs  with SID  zero are  free slots
    private static short buffer[];

    // creates the TDF buffer
    public static void init(int size)
    {
        // the buffer holds 'size' pairs of the form (SID, value)
        buffer=new short[size*2];
    }

    // refreshes a value in the buffer.
    public static void put(short sensorId,int value)
    {
        short i=0;
        while(true)
        {
            // is we  have reached free  slots, let's allocate  a slot
            // for this SID
            if( buffer[i]==0)
                buffer[i]=sensorId ;
            
            if(buffer[i]==sensorId)
                break;

            i+=2;
            // note: this loop will fail  with an "Array Out Of Bounds
            // Exception" if the buffer is undersized
        }
        // update the right-hand side of the pair
        buffer[i+1]=(short)value;
    }

    // pops 'count' (SID,values) pairs out  of the buffer. An index is
    // cached so that  subsequent calls get different SIDs  in a round
    // robin fashion.
    private static short nextPairIndex;
    public static short[] read(int count)
    {
        short result[]=new short[count*2];

        for(short i=0;i<count;i++)
        {
            result[2*i]   = buffer[nextPairIndex];
            result[2*i+1] = buffer[nextPairIndex+1];

            nextPairIndex+=2;
            if(nextPairIndex>=buffer.length || buffer[nextPairIndex]==0)
                nextPairIndex=0;
        }

        return result;
    }
}
''' % generated_text)

    
