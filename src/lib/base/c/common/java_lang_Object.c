/*
 * java_lang_Object.c
 * 
 * Copyright (c) 2008-2010 CSIRO, Delft University of Technology.
 * 
 * This file is part of Darjeeling.
 * 
 * Darjeeling is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * Darjeeling is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with Darjeeling.  If not, see <http://www.gnu.org/licenses/>.
 */
 
#include <stddef.h>
#include <string.h>

#include "execution.h"
#include "array.h"
#include "vmthread.h"
#include "vm.h"

#include "pointerwidth.h"
#include "jstring.h"

// generated by the infuser
#include "jlib_base.h"

// void java.lang.Object.wait(int)
void java_lang_Object_void_wait_int()
{
	int32_t timeOut = dj_exec_stackPopInt();
	// Don't pop, just peek the object reference off the runtime stack,
	// because it's cleared by the VM's frame management.
	dj_object * object = (dj_object*)REF_TO_VOIDP(dj_exec_stackPeekRef());

	dj_thread * thread = dj_exec_getCurrentThread();

	dj_thread_wait(thread, object, timeOut);
	dj_exec_breakExecution();
}

// void java.lang.Object.wait()
void java_lang_Object_void_wait()
{
	// Don't pop, just peek the object reference off the runtime stack,
	// because it's cleared by the VM's frame management.
	dj_object * object = (dj_object*)REF_TO_VOIDP(dj_exec_stackPeekRef());
	dj_thread * thread = dj_exec_getCurrentThread();

	dj_thread_wait(thread, object, 0);
	dj_exec_breakExecution();
}

// void java.lang.Object.notify()
void java_lang_Object_void_notify()
{
	// Don't pop, just peek the object reference off the runtime stack,
	// because it's cleared by the VM's frame management.
	dj_object * object = (dj_object*)REF_TO_VOIDP(dj_exec_stackPeekRef());

	// make sure the thread owns the lock
	// TODO implement this check

	dj_vm_notify(dj_exec_getVM(), object, false);
}

// void java.lang.Object.notifyAll()
void java_lang_Object_void_notifyAll()
{
	// Don't pop, just peek the object reference off the runtime stack,
	// because it's cleared by the VM's frame management.
	dj_object * object = (dj_object*)REF_TO_VOIDP(dj_exec_stackPeekRef());
	dj_vm_notify(dj_exec_getVM(), object, false);
}

void java_lang_Object_java_lang_String_toString()
{
	// Don't pop, just peek the object reference off the runtime stack,
	// because it's cleared by the VM's frame management.
	dj_object * obj = REF_TO_VOIDP(dj_exec_stackPeekRef());

	// Get class definition
	runtime_id_t classRuntimeId = dj_mem_getChunkId(obj);
	dj_global_id classGlobalId = dj_vm_getRuntimeClass(dj_exec_getVM(), classRuntimeId);

	// Get class name
	dj_di_pointer classDefinition = dj_global_id_getClassDefinition(classGlobalId);
	dj_local_id classNameLocalId = dj_di_classDefinition_getClassName(classDefinition);
	dj_global_id classNameGlobalId = dj_global_id_resolve(classGlobalId.infusion, classNameLocalId);

	dj_object * string = dj_jstring_createFromGlobalId(dj_exec_getVM(), classNameGlobalId);

	if (string==NULL)
		dj_exec_createAndThrow(BASE_CDEF_java_lang_OutOfMemoryError);
	else
		dj_exec_stackPushRef(VOIDP_TO_REF(string));

}

void java_lang_Object_int_hashCode()
{
	// Don't pop, just peek the object reference off the runtime stack,
	// because it's cleared by the VM's frame management.
	dj_object * object = (dj_object*)REF_TO_VOIDP(dj_exec_stackPeekRef());

	dj_exec_stackPushInt((int)object);
}
