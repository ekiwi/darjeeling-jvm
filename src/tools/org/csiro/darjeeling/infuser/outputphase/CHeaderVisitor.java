/*
 *	CHeaderVisitor.java
 * 
 *	Copyright (c) 2008 CSIRO, Delft University of Technology.
 * 
 *	This file is part of Darjeeling.
 * 
 *	Darjeeling is free software: you can redistribute it and/or modify
 *	it under the terms of the GNU General Public License as published by
 *	the Free Software Foundation, either version 3 of the License, or
 *	(at your option) any later version.
 *
 *	Darjeeling is distributed in the hope that it will be useful,
 *	but WITHOUT ANY WARRANTY; without even the implied warranty of
 *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *	GNU General Public License for more details.
 * 
 *	You should have received a copy of the GNU General Public License
 *	along with Darjeeling.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.csiro.darjeeling.infuser.outputphase;

import java.io.PrintWriter;

import org.apache.bcel.generic.Type;
import org.csiro.darjeeling.infuser.structure.DescendingVisitor;
import org.csiro.darjeeling.infuser.structure.Element;
import org.csiro.darjeeling.infuser.structure.ParentElement;
import org.csiro.darjeeling.infuser.structure.elements.AbstractHeader;
import org.csiro.darjeeling.infuser.structure.elements.internal.InternalClassDefinition;
import org.csiro.darjeeling.infuser.structure.elements.internal.InternalClassList;
import org.csiro.darjeeling.infuser.structure.elements.internal.InternalInfusion;
import org.csiro.darjeeling.infuser.structure.elements.internal.InternalMethodDefinition;
import org.csiro.darjeeling.infuser.structure.elements.internal.InternalMethodDefinitionList;

public class CHeaderVisitor extends DescendingVisitor
{
	
	private PrintWriter writer;
	private String infusionName;
	
	public CHeaderVisitor(PrintWriter writer)
	{
		this.writer = writer;
	}
	
	//@Override
	public void visit(InternalInfusion element)
	{
		AbstractHeader header = element.getHeader();
		infusionName = header.getInfusionName();
		
		writer.printf("#ifndef __%s_definitions_h\n", infusionName);
		writer.printf("#define __%s_definitions_h\n", infusionName);
		writer.println("");

        writer.println("/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *");
        writer.println(" * Warning ! this file is machine-generated by the infuser tool !");
        writer.println(" * Do not try to edit it by hand (or do not complain afterwards :-)");
        writer.println(" * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */");

        
		visit((ParentElement<Element>)element);

		writer.println("");
		writer.println("#endif");
		writer.println("");
	}
	
	public void visit(InternalClassList element)
	{
		writer.println("// Class definitions");
		super.visit(element);
		writer.println("");
	}
	
	public void visit(InternalClassDefinition element)
	{
		String className = element.getName();
		className = className.replaceAll("\\.", "_").replaceAll("\\$", "_inner_");
		writer.printf("#define %s_CDEF_%s %d\n",
				infusionName.toUpperCase(),
				className,
				element.getGlobalId().getEntityId()
				);
	}

	public void visit(InternalMethodDefinitionList element)
	{
		writer.println("// Method definitions");
		super.visit(element);
		writer.println("");
	}
	
	public void visit(InternalMethodDefinition element)
	{
		Type returnType = Type.getReturnType(element.getSignature());
		Type argTypes[] = Type.getArgumentTypes(element.getSignature());
		String descr = returnType + "_" + element.getName();
		for (Type argType : argTypes) descr += "_" + argType.toString();
		descr = descr.toString().replaceAll("\\p{Punct}", "_");
		
		writer.printf("#define %s_MDEF_%s %d\n",
				infusionName.toUpperCase(),
				descr,
				element.getGlobalId().getEntityId()
				);
	}
	
	/*
	
	//@Override
	public void visit(InternalMethodDefinition element)
	{
		Type returnType = Type.getReturnType(element.getDescriptor());
		Type argTypes[] = Type.getArgumentTypes(element.getDescriptor());
		String descr = returnType + "_" + element.getMethodName();
		for (Type argType : argTypes) descr += "_" + argType.toString();
		descr = descr.toString().replaceAll("\\p{Punct}", "_");
		
		writer.printf("#define METHODDEF_%s %d\n",
				descr,
				element.getGlobalId().getEntityId()
				);
	}
	
	//@Override
	public void visit(InternalMethodImplementation element)
	{
		String className = element.getParentClass().getClassName().toUpperCase().replaceAll("\\.", "_").replaceAll("\\$", "_inner_");
		Type returnType = Type.getReturnType(element.getMethodDef().getDescriptor());
		Type argTypes[] = Type.getArgumentTypes(element.getMethodDef().getDescriptor());
		String descr = returnType + "_" + element.getMethodDef().getMethodName();
		for (Type argType : argTypes) descr += "_" + argType.toString();
		descr = descr.toString().replaceAll("\\p{Punct}", "_");
		
		writer.printf("#define METHODIMPL_%s_%s %d\n",
				className,
				descr,
				element.getGlobalId().getEntityId()
				);
	}
	
	//@Override
	public void visit(InternalClassDefinition element)
	{
		String className = element.getClassName().toUpperCase().replaceAll("\\.", "_").replaceAll("\\$", "_inner_");
		
		writer.printf("#define %s %d\n",
				className,
				element.getGlobalId().getEntityId()
				);
	}
	
	*/

	//@Override
	public void visit(Element element)
	{
	}

}
